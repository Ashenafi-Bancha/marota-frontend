create table if not exists public.favorites (
  id bigint generated by default as identity primary key,
  user_id uuid not null references auth.users(id) on delete cascade,
  course_title text not null,
  created_at timestamptz not null default now(),
  unique (user_id, course_title)
);

create table if not exists public.enrollments (
  id bigint generated by default as identity primary key,
  user_id uuid not null references auth.users(id) on delete cascade,
  course_title text not null,
  progress int not null default 0,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  unique (user_id, course_title),
  constraint enrollments_progress_range check (progress >= 0 and progress <= 100)
);

create or replace function public.set_updated_at()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

create trigger set_enrollments_updated_at
before update on public.enrollments
for each row
execute function public.set_updated_at();

alter table public.favorites enable row level security;
alter table public.enrollments enable row level security;

create policy "Favorites select own" on public.favorites
for select
using (auth.uid() = user_id);

create policy "Favorites insert own" on public.favorites
for insert
with check (auth.uid() = user_id);

create policy "Favorites delete own" on public.favorites
for delete
using (auth.uid() = user_id);

create policy "Enrollments select own" on public.enrollments
for select
using (auth.uid() = user_id);

create policy "Enrollments insert own" on public.enrollments
for insert
with check (auth.uid() = user_id);

create policy "Enrollments update own" on public.enrollments
for update
using (auth.uid() = user_id)
with check (auth.uid() = user_id);

create policy "Enrollments delete own" on public.enrollments
for delete
using (auth.uid() = user_id);

insert into storage.buckets (id, name, public)
values ('certificate', 'certificate', false)
on conflict (id) do nothing;

create policy "Certificate read own" on storage.objects
for select
using (
  bucket_id = 'certificate'
  and auth.uid()::text = (storage.foldername(name))[1]
);

create policy "Certificate upload own" on storage.objects
for insert
with check (
  bucket_id = 'certificate'
  and auth.uid()::text = (storage.foldername(name))[1]
);

create policy "Certificate update own" on storage.objects
for update
using (
  bucket_id = 'certificate'
  and auth.uid()::text = (storage.foldername(name))[1]
)
with check (
  bucket_id = 'certificate'
  and auth.uid()::text = (storage.foldername(name))[1]
);

create policy "Certificate delete own" on storage.objects
for delete
using (
  bucket_id = 'certificate'
  and auth.uid()::text = (storage.foldername(name))[1]
);
